<?php
/**
 * @file
 * Basic functionality for the tripal module
 */

/**
 * @defgroup tripal_feature Feature Module
 * @ingroup tripal_modules
 * @{
 * Integrates the Chado Sequence module with Drupal Nodes & Views
 * @}
 */

require_once 'api/tripal_feature.api.inc';
require_once 'api/tripal_feature.schema.api.inc';
require_once 'api/tripal_feature.DEPRECATED.inc';

require_once 'theme/tripal_feature.theme.inc';

require_once 'includes/tripal_feature.admin.inc';
require_once 'includes/tripal_feature.fasta_loader.inc';
require_once 'includes/tripal_feature.gff_loader.inc';
require_once 'includes/tripal_feature.seq_extract.inc';
require_once 'includes/tripal_feature.delete.inc';
require_once 'includes/tripal_feature.chado_node.inc';
require_once 'includes/tripal_feature.blocks.inc';

/**
 * Implements hook_views_api().
 *
 * Essentially this hook tells drupal that there is views support for
 *  for this module which then includes tripal_db.views.inc where all the
 *  views integration code is
 *
 * @ingroup tripal_feature
 */
function tripal_feature_views_api() {
  return array(
    'api' => 3.0,
  );
}

/**
 * Implements hook_help().
 *
 * Display help and module information
 *
 * @param
 *   path which path of the site we're displaying help
 * @param
 *   arg array that holds the current path as would be returned from arg() function
 *
 * @return
 *   help text for the path
 *
 * @ingroup tripal_feature
 */
function tripal_feature_help($path, $arg) {
  $output = '';
  switch ($path) {
  case "admin/help#tripal_feature":
    $output='<p>' . t("Displays links to nodes created on this date") . '</p>';
    break;
  }
  return $output;
}

/**
 * Implements hook_permission().
 *
 *  Set the permission types that the chado module uses.  Essentially we
 *  want permissionis that protect creation, editing and deleting of chado
 *  data objects
 *
 * @ingroup tripal_feature
 */
function tripal_feature_permission() {
  return array(
    'access chado_feature content' => array(
      'title' => t('View Features'),
      'description' => t('Allow users to view feature pages.'),
    ),
    'create chado_feature content' => array(
      'title' => t('Create Features'),
      'description' => t('Allow users to create new feature pages.'),
    ),
    'delete chado_feature content' => array(
      'title' => t('Delete Features'),
      'description' => t('Allow users to delete feature pages.'),
    ),
    'edit chado_feature content' => array(
      'title' => t('Edit Features'),
      'description' => t('Allow users to edit feature pages.'),
    ),
    'adminster tripal feature' => array(
      'title' => t('Administer Features'),
      'description' => t('Allow users to administer all features.'),
    ),
  );
}

/**
 * Implements hook_menu().
 *
 * Menu items are automatically added for the new node types created
 *  by this module to the 'Create Content' Navigation menu item.  This function
 *  adds more menu items needed for this module.
 *
 * @ingroup tripal_feature
 */
function tripal_feature_menu() {
  $items = array();

  // the administative settings menu
  $items['find/sequences'] = array(
    'title' => 'Sequence Retrieval',
    'description' => 'Download a file of sequences',
    'page callback' => 'tripal_feature_seq_extract_page',
    'access arguments' => array('access chado_feature content'),
    'type' => MENU_CALLBACK,
  );

  $items['find/sequences/ajax'] = array(
    'title' => 'Sequence Retrieval',
    'page callback' => 'tripal_feature_seq_extract_form_ahah_update',
    'access arguments' => array('access chado_feature content'),
    'type' => MENU_CALLBACK,
  );

  // the menu link for addressing any feature (by name, uniquename, synonym)
  $items['feature/%'] = array(
    'page callback' => 'tripal_feature_match_features_page',
    'page arguments' => array(1),
    'access arguments' => array('access chado_feature content'),
    'type' => MENU_LOCAL_TASK,
  );

  // the administative settings menu
  $items['admin/tripal/chado/tripal_feature'] = array(
    'title' => 'Features',
    'description' => 'A biological sequence or a section of a biological sequence, or a collection of such sections.',
    'page callback' => 'tripal_feature_admin_feature_view',
    'access arguments' => array('administer tripal feature'),
    'type' => MENU_NORMAL_ITEM,
  );

  $items['admin/tripal/chado/tripal_feature/delete'] = array(
    'title' => ' Delete',
    'description' => 'Delete multiple features from Chado',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tripal_feature_delete_form'),
    'access arguments' => array('administer tripal feature'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 2
  );
  $items['admin/tripal/chado/tripal_feature/sync'] = array(
    'title' => ' Sync',
    'description' => 'Create pages on this site for features stored in Chado',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('chado_node_sync_form', 'tripal_feature', 'chado_feature'),
    'access arguments' => array('administer tripal feature'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 1
  );
  $items['admin/tripal/chado/tripal_feature/configuration'] = array(
    'title' => 'Settings',
    'description' => 'Configure the Tripal Feature module.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tripal_feature_admin'),
    'access arguments' => array('administer tripal feature'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 5
  );
  $items['admin/tripal/chado/tripal_feature/help'] = array(
    'title' => 'Help',
    'description' => 'Help with the Tripal Feature module.',
    'page callback' => 'theme',
    'page arguments' => array('tripal_feature_help'),
    'access arguments' => array('administer tripal feature'),
    'type' => MENU_LOCAL_TASK,
    'weight' =>  10
  );

  /** Loaders */
  $items['admin/tripal/loaders/fasta_loader'] = array(
    'title' => 'FASTA file Loader',
    'description' => 'Load sequences from a multi-FASTA file into Chado',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tripal_feature_fasta_load_form'),
    'access arguments' => array('administer tripal feature'),
    'type' => MENU_NORMAL_ITEM,
  );
  $items['admin/tripal/loaders/gff3_load'] = array(
    'title' => 'GFF3 file Loader',
    'description' => 'Import a GFF3 file into Chado',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tripal_feature_gff3_load_form'),
    'access arguments' => array('administer tripal feature'),
    'type' => MENU_NORMAL_ITEM,
  );

  // Enable admin view
  $items['admin/tripal/chado/tripal_feature/views/features/enable'] = array(
    'title' => 'Enable feature Administrative View',
    'page callback' => 'tripal_views_admin_enable_view',
    'page arguments' => array('tripal_feature_admin_features', 'admin/tripal/chado/tripal_feature'),
    'access arguments' => array('administer tripal feature'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_theme().
 *
 * We need to let drupal know about our theme functions and their arguments.
 *  We create theme functions to allow users of the module to customize the
 *  look and feel of the output generated in this module
 *
 * @ingroup tripal_feature
 */
function tripal_feature_theme($existing, $type, $theme, $path) {
  $core_path = drupal_get_path('module', 'tripal_core');

  $items = array(
    'node__chado_feature' => array(
      'template' => 'node--chado-generic',
      'render element' => 'node',
      'base hook' => 'node',
      'path' => "$core_path/theme",
    ),
    'tripal_feature_alignments' => array(
      'variables' => array('node' => NULL),
      'template' => 'tripal_feature_alignments',
      'path' => "$path/theme/tripal_feature",
    ),
    'tripal_feature_analyses' => array(
      'variables' => array('node' => NULL),
      'template' => 'tripal_feature_analyses',
      'path' => "$path/theme/tripal_feature",
    ),
    'tripal_feature_base' => array(
      'variables' => array('node' => NULL),
      'template' => 'tripal_feature_base',
      'path' => "$path/theme/tripal_feature",
    ),
    'tripal_feature_sequence' => array(
      'variables' => array('node' => NULL),
      'template' => 'tripal_feature_sequence',
      'path' => "$path/theme/tripal_feature",
    ),
    'tripal_feature_proteins' => array(
      'variables' => array('node' => NULL),
      'template' => 'tripal_feature_proteins',
      'path' => "$path/theme/tripal_feature",
    ),
    'tripal_feature_publications' => array(
      'variables' => array('node' => NULL),
      'template' => 'tripal_feature_publications',
      'path' => "$path/theme/tripal_feature",
    ),
    'tripal_feature_synonyms' => array(
      'variables' => array('node' => NULL),
      'template' => 'tripal_feature_synonyms',
      'path' => "$path/theme/tripal_feature",
    ),
    'tripal_feature_references' => array(
      'variables' => array('node' => NULL),
      'template' => 'tripal_feature_references',
      'path' => "$path/theme/tripal_feature",
    ),
    'tripal_feature_properties' => array(
      'variables' => array('node' => NULL),
      'template' => 'tripal_feature_properties',
      'path' => "$path/theme/tripal_feature",
    ),
    'tripal_feature_terms' => array(
      'variables' => array('node' => NULL),
      'template' => 'tripal_feature_terms',
      'path' => "$path/theme/tripal_feature",
    ),
    'tripal_feature_relationships' => array(
      'variables' => array('node' => NULL),
      'template' => 'tripal_feature_relationships',
      'path' => "$path/theme/tripal_feature",
    ),
    'tripal_feature_help' => array(
      'template' => 'tripal_feature_help',
      'variables' =>  array(NULL),
      'path' => "$path/theme/"
    ),

    // template for the organism page
    'tripal_organism_feature_browser' => array(
      'variables' => array('node' => NULL),
      'template' => 'tripal_organism_feature_browser',
      'path' => "$path/theme/tripal_organism",
    ),
    'tripal_organism_feature_counts' => array(
      'variables' => array('node' => NULL),
      'template' => 'tripal_organism_feature_counts',
      'path' => "$path/theme/tripal_organism",
    ),

    // themed forms
    'tripal_feature_seq_extract_form' => array(
       'arguments' => array('form'),
    ),

    // themed teaser
    'tripal_feature_teaser' => array(
      'variables' => array('node' => NULL),
      'template' => 'tripal_feature_teaser',
      'path' => "$path/theme/tripal_feature",
    ),
  );

  return $items;
}

/**
 * Load the locations for a given feature
 *
 * @param $feature_id
 *   The feature to look up locations for
 * @param $side
 *   Whether the feature is the scrfeature, 'as_parent', or feature, 'as_child'
 * @param $aggregate
 *   Whether or not to get the locations for related features
 *
 * @ingroup tripal_feature
 */
function tripal_feature_load_featurelocs($feature_id, $side = 'as_parent', $aggregate = 1) {

  $sql = "
    SELECT
       F.name, F.feature_id, F.uniquename,
       FS.name as src_name, FS.feature_id as src_feature_id, FS.uniquename as src_uniquename,
       CVT.name as cvname, CVT.cvterm_id,
       CVTS.name as src_cvname, CVTS.cvterm_id as src_cvterm_id,
       FL.fmin, FL.fmax, FL.is_fmin_partial, FL.is_fmax_partial,FL.strand, FL.phase
     FROM {featureloc} FL
       INNER JOIN {feature} F   ON FL.feature_id = F.feature_id
       INNER JOIN {feature} FS  ON FS.feature_id = FL.srcfeature_id
       INNER JOIN {cvterm} CVT  ON F.type_id     = CVT.cvterm_id
       INNER JOIN {cvterm} CVTS ON FS.type_id    = CVTS.cvterm_id
   ";
  if (strcmp($side, 'as_parent')==0) {
    $sql .= "WHERE FL.srcfeature_id = :feature_id ";
  }
  if (strcmp($side, 'as_child')==0) {
    $sql .= "WHERE FL.feature_id = :feature_id ";
  }

  $flresults = chado_query($sql, array(':feature_id' => $feature_id));

  // copy the results into an array
  $i=0;
  $featurelocs = array();
  while ($loc = $flresults->fetchObject()) {
    // if a drupal node exists for this feature then add the nid to the
    // results object
    $loc->fnid = chado_get_nid_from_id('feature', $loc->feature_id);
    $loc->snid = chado_get_nid_from_id('feature', $loc->src_feature_id);
    // add the result to the array
    $featurelocs[$i++] = $loc;
  }

  // Add the relationship feature locs if aggregate is turned on
  if ($aggregate and strcmp($side, 'as_parent')==0) {
    // get the relationships for this feature without substituting any children
    // for the parent. We want all relationships
    $relationships = tripal_feature_get_aggregate_relationships($feature_id, 0);
    foreach ($relationships as $rindex => $rel) {
      // get the featurelocs for each of the relationship features
      $rel_featurelocs = tripal_feature_load_featurelocs($rel->subject_id, 'as_child', 0);
      foreach ($rel_featurelocs as $findex => $rfloc) {
        $featurelocs[$i++] = $rfloc;
      }
    }
  }

  usort($featurelocs, 'tripal_feature_sort_locations');
  return $featurelocs;
}

/**
 * Used to sort the feature locs by start position
 *
 * @param $a
 *   One featureloc record (as an object)
 * @param $b
 *   The other featureloc record (as an object)
 *
 * @return
 *   Which feature location comes first
 *
 * @ingroup tripal_feature
 */
function tripal_feature_sort_locations($a, $b) {
  return strnatcmp($a->fmin, $b->fmin);
}

/**
 * Get the relationships for a feature.
 *
 * @param $feature_id
 *   The feature to get relationships for
 * @param $side
 *   The side of the relationship this feature is (ie: 'as_subject' or 'as_object')
 *
 * @ingroup tripal_feature
 */
function tripal_feature_load_relationships($feature_id, $side = 'as_subject') {
  // get the relationships for this feature.  The query below is used for both
  // querying the object and subject relationships
  $sql = "
    SELECT
      FS.name as subject_name, FS.uniquename as subject_uniquename,
      CVTS.name as subject_type, CVTS.cvterm_id as subject_type_id,
      FR.subject_id, FR.type_id as relationship_type_id, FR.object_id, FR.rank,
      CVT.name as rel_type,
      FO.name as object_name, FO.uniquename as object_uniquename,
      CVTO.name as object_type, CVTO.cvterm_id as object_type_id
    FROM {feature_relationship} FR
     INNER JOIN {cvterm} CVT  ON FR.type_id    = CVT.cvterm_id
     INNER JOIN {feature} FS  ON FS.feature_id = FR.subject_id
     INNER JOIN {feature} FO  ON FO.feature_id = FR.object_id
     INNER JOIN {cvterm} CVTO ON FO.type_id    = CVTO.cvterm_id
     INNER JOIN {cvterm} CVTS ON FS.type_id    = CVTS.cvterm_id
  ";
  if (strcmp($side, 'as_object')==0) {
    $sql .= " WHERE FR.object_id = :feature_id";
  }
  if (strcmp($side, 'as_subject')==0) {
    $sql .= " WHERE FR.subject_id = :feature_id";
  }
  $sql .= " ORDER BY FR.rank";

  // get the relationships
  $results = chado_query($sql, array(':feature_id' => $feature_id));


  // iterate through the relationships, put these in an array and add
  // in the Drupal node id if one exists
  $i=0;
  $nodesql = "SELECT nid FROM {chado_feature} WHERE feature_id = :feature_id";
  $relationships = array();
  while ($rel = $results->fetchObject()) {
    $node = db_query($nodesql, array(':feature_id' => $rel->subject_id))->fetchObject();
    if ($node) {
      $rel->subject_nid = $node->nid;
    }
    $node = db_query($nodesql, array(':feature_id' => $rel->object_id))->fetchObject();
    if ($node) {
      $rel->object_nid = $node->nid;
    }
    $relationships[$i++] = $rel;
  }
  return $relationships;
}

/**
 * Get features related to the current feature to a given depth. Recursive function.
 *
 * @param $feature_id
 * @param $substitute
 * @param $levels
 * @param $base_type_id
 * @param $depth
 *
 * @ingroup tripal_feature
 */
function tripal_feature_get_aggregate_relationships($feature_id, $substitute=1,
  $levels=0, $base_type_id=NULL, $depth=0) {

  // we only want to recurse to as many levels deep as indicated by the
  // $levels variable, but only if this variable is > 0. If 0 then we
  // recurse until we reach the end of the relationships tree.
  if ($levels > 0 and $levels == $depth) {
    return NULL;
  }

  // first get the relationships for this feature
  return tripal_feature_load_relationships($feature_id, 'as_object');

}

/**
 * Get the sequence this feature is located on
 *
 * @param $feature_id
 * @param $featurelocs
 *
 * @ingroup tripal_feature
 */
function tripal_feature_load_featureloc_sequences($feature_id, $featurelocs) {

  // if we don't have any featurelocs then no point in continuing
  if (!$featurelocs) {
    return array();
  }

  // get the list of relationships (including any aggregators) and iterate
  // through each one to find information needed to color-code the reference sequence
  $relationships = tripal_feature_get_aggregate_relationships($feature_id);
  if (!$relationships) {
    return array();
  }


  // iterate through each of the realtionships features and get their
  // locations
  foreach ($relationships as $rindex => $rel) {
    // get the featurelocs for each of the relationship features
    $rel_featurelocs = tripal_feature_load_featurelocs($rel->subject_id, 'as_child', 0);
    foreach ($rel_featurelocs as $rfindex => $rel_featureloc) {
      // keep track of this unique source feature
      $src = $rel_featureloc->src_feature_id . "-" . $rel_featureloc->src_cvterm_id;

      // copy over the results to the relationship object.  Since there can
      // be more than one feature location for each relationship feature we
      // use the '$src' variable to keep track of these.
      $rel->featurelocs = new stdClass();
      $rel->featurelocs->$src = new stdClass();
      $rel->featurelocs->$src->src_uniquename = $rel_featureloc->src_uniquename;
      $rel->featurelocs->$src->src_cvterm_id  = $rel_featureloc->src_cvterm_id;
      $rel->featurelocs->$src->src_cvname     = $rel_featureloc->src_cvname;
      $rel->featurelocs->$src->fmin           = $rel_featureloc->fmin;
      $rel->featurelocs->$src->fmax           = $rel_featureloc->fmax;
      $rel->featurelocs->$src->src_name       = $rel_featureloc->src_name;

      // keep track of the individual parts for each relationship
      $start = $rel->featurelocs->$src->fmin;
      $end   = $rel->featurelocs->$src->fmax;
      $type  = $rel->subject_type;
      $rel_locs[$src]['parts'][$start][$type]['start'] = $start;
      $rel_locs[$src]['parts'][$start][$type]['end']   = $end;
      $rel_locs[$src]['parts'][$start][$type]['type']  = $type;
    }
  }

  // the featurelocs array provided to the function contains the locations
  // where this feature is found.   We want to get the sequence for each
  // location and then annotate it with the parts found from the relationships
  // locations determiend above.
  $floc_sequences = array();
  foreach ($featurelocs as $featureloc) {

    // build the src name so we can keep track of the different parts for each feature
    $src = $featureloc->srcfeature_id->feature_id . "-" . $featureloc->srcfeature_id->type_id->cvterm_id;

    // orient the parts to the beginning of the feature sequence
    if (!empty($rel_locs[$src]['parts'])) {
      $parts = $rel_locs[$src]['parts'];
      $rparts = array();  // we will fill this up if we're on the reverse strand

      foreach ($parts as $start => $types) {
        foreach ($types as $type_name => $type) {
          if ($featureloc->strand >= 0) {
             // this is on the forward strand.  We need to convert the start on the src feature to the
             // start on this feature's sequence
             $parts[$start][$type_name]['start'] = $parts[$start][$type_name]['start'] - $featureloc->fmin;
             $parts[$start][$type_name]['end']   = $parts[$start][$type_name]['end'] - $featureloc->fmin;
             $parts[$start][$type_name]['type']  = $type_name;
          }
          else {
             // this is on the reverse strand.  We need to swap the start and stop and calculate from the
             // begining of the reverse sequence
             $size = ($featureloc->fmax - $featureloc->fmin);
             $start_orig = $parts[$start][$type_name]['start'];
             $end_orig = $parts[$start][$type_name]['end'];
             $new_start = $size - ($end_orig - $featureloc->fmin);
             $new_end = $size - ($start_orig - $featureloc->fmin);

             $rparts[$new_start][$type_name]['start'] = $new_start;
             $rparts[$new_start][$type_name]['end']   = $new_end;
             $rparts[$new_start][$type_name]['type']  = $type_name;
          }
        }
      }

      // now sort the parts
      // if we're on the reverse strand we need to resort
      if ($featureloc->strand >= 0) {
        usort($parts, 'tripal_feature_sort_rel_parts_by_start');
      }
      else {
        usort($rparts, 'tripal_feature_sort_rel_parts_by_start');
        $parts = $rparts;
      }

      $floc_sequences[$src]['src'] = $src;
      $floc_sequences[$src]['type'] = $featureloc->feature_id->type_id->name;
      $args = array(':feature_id' => $featureloc->srcfeature_id->feature_id);
      $start = $featureloc->fmin + 1;
      $size = $featureloc->fmax - $featureloc->fmin;
      // TODO: fix the hard coded $start and $size
      // the $start and $size variables are hard-coded in the SQL statement
      // because the db_query function places quotes around all placeholders
      // (e.g. :start & :size) and screws up the substring function
      $sql = "
        SELECT substring(residues from $start for $size) as residues
        FROM {feature}
        WHERE feature_id = :feature_id
      ";
      $sequence = chado_query($sql, $args)->fetchObject();
      $residues = $sequence->residues;
      if ($featureloc->strand < 0) {
         $residues = tripal_feature_reverse_complement($residues);
      }
      $strand = '.';
      if ($featureloc->strand == 1) {
        $strand = '+';
      }
      elseif ($featureloc->strand == -1) {
        $strand = '-';
      }
      $defline = $featureloc->feature_id->name . " " . $featureloc->srcfeature_id->name . ":" . ($featureloc->fmin + 1) . ".." . $featureloc->fmax . " " . $strand;
      $floc_sequences[$src]['formatted_seq'] =  tripal_feature_color_sequence($residues, $parts, $defline);
    }
  }
  return $floc_sequences;
}

/**
 * This function is for features that align through an intermediate such
 * as 'EST_match' or 'match'.  This occurs in the case where two sequences
 * align but where one does not align perfectly.  Some ESTs may be in a contig
 * but not all of the EST.  Portions may overhang and not be included in the
 * consensus if quality is bad.
 * For example:
 *    Feature 1: Contig --------------------
 *    Feature 2: EST_match           -------
 *    Feature 3: EST                 ---------
 *
 * The feature provided to the function will always be the feature 1.  The
 * featureloc columns prefixed with 'right' (e.g. right_fmin) belong to the
 * alignment of feature 3 with feature 2
 *
 * Features may align to more than one feature and are not matches. We do
 * not want to include these, so we have to filter on the SO terms:
 * match, or %_match
 *
 * @ingroup tripal_feature
 */
function tripal_feature_get_matched_alignments($feature) {

   $sql = "
     SELECT
       FL1.featureloc_id    as left_featureloc_id,
       FL1.srcfeature_id    as left_srcfeature_id,
       FL1.feature_id       as left_feature_id,
       FL1.fmin             as left_fmin,
       FL1.is_fmin_partial  as left_is_fmin_partial,
       FL1.fmax             as left_fmax,
       FL1.is_fmax_partial  as left_is_fmax_partial,
       FL1.strand           as left_strand,
       FL1.phase            as left_phase,
       FL1.locgroup         as left_locgroup,
       FL1.rank             as left_rank,
       FL2.featureloc_id    as right_featureloc_id,
       FL2.srcfeature_id    as right_srcfeature_id,
       FL2.feature_id       as right_feature_id,
       FL2.fmin             as right_fmin,
       FL2.is_fmin_partial  as right_is_fmin_partial,
       FL2.fmax             as right_fmax,
       FL2.is_fmax_partial  as right_is_fmax_partial,
       FL2.strand           as right_strand,
       FL2.phase            as right_phase,
       FL2.locgroup         as right_locgroup,
       FL2.rank             as right_rank
     FROM {feature} F1
       INNER JOIN {featureloc} FL1 on FL1.srcfeature_id = F1.feature_id
       INNER JOIN {feature} F2 on FL1.feature_id = F2.feature_id
       INNER JOIN {featureloc} FL2 on FL2.feature_id = F2.feature_id
       INNER JOIN {cvterm} CVT2 on F2.type_id = CVT2.cvterm_id
     WHERE
       F1.feature_id = :feature_id  AND
       (CVT2.name = 'match' or CVT2.name like '%_match')
     ORDER BY FL1.fmin
   ";

   $results = chado_query($sql, array(':feature_id' => $feature->feature_id));

   // iterate through the results and add them to our featurelocs array
   $featurelocs = array();
   while ($fl = $results->fetchObject()) {
     // ignore featurelocs where the left and right srcfeature is the same
     if (strcmp($fl->left_srcfeature_id, $fl->right_srcfeature_id) == 0) {
       continue;
     }
     $featurelocs[] = $fl ;
   }
   return $featurelocs;
}

/**
 * Load the arguments for the organism feature counts browser
 *
 * @param $organism
 *  The organism of interest
 *
 * @ingroup tripal_feature
 */
function tripal_feature_load_organism_feature_counts($organism) {

  $args = array();
  $order = array();
  $names = array();

  // build the where clause for the SQL statement if we have a custom term list
  // we'll also keep track of the names the admin provided (if any) and the
  // order that the terms should appear.
  $is_custom = 0;
  $temp = rtrim(variable_get('tripal_feature_summary_report_mapping', ''));
  $where = '';
  if ($temp) {
    $is_custom = 1;
    $temp = explode("\n", $temp);
    $i = 0;
    foreach ($temp as $value) {
      // separate the key value pairs
      $temp2 = explode("=", $value);
      $feature_type = rtrim($temp2[0]);
      $order[] = $feature_type;  // save the order of the these terms
      $where .= " OFC.feature_type = :name$i OR ";
      $args[":name$i"] = rtrim($temp2[0]);
      
      // if the admin specified a new name then store that otherwise use the
      // the default sequence ontology term name
      if(count($temp2) == 2) {
        $names[] = rtrim($temp2[1]);
      }
      else {
        $names[] = $feature_type;
      }
      $i++;
    }
    if ($where) {
      $where = drupal_substr($where, 0, -4);  # remove OR from the end
      $where = "($where) AND";
    }
  }

  // get the feature counts.  This is dependent on a materialized view
  // installed with the organism module
  $sql = "
    SELECT OFC.num_features,OFC.feature_type,CVT.definition
    FROM {organism_feature_count} OFC
      INNER JOIN {cvterm} CVT on OFC.cvterm_id = CVT.cvterm_id
    WHERE $where organism_id = :organism_id
    ORDER BY num_features desc
  ";
  $args[':organism_id'] = $organism->organism_id;
  $org_features = chado_query($sql, $args);

  // iterate through the types
  $types = array();
  while ($type = $org_features->fetchObject()) {
    $types[$type->feature_type] = $type;
    // if we don't have an order this means we didn't go through the loop
    // above to set the names, so do that now
    if (!$is_custom) {
      $names[] = $type->feature_type;
      $order[] = $type->feature_type;
    }
  }

  // now reorder the types
  $ordered_types = array();
  foreach ($order as $type) {
    $ordered_types[] = $types[$type];
  }
  return array( 
    'types' => $ordered_types, 
    'names' => $names
  );
}

/**
 * Used to sort the list of relationship parts by start position
 *
 * @ingroup tripal_feature
 */
function tripal_feature_sort_rel_parts_by_start($a, $b) {
  foreach ($a as $type_name => $details) {
     $astart = $a[$type_name]['start'];
     break;
  }
  foreach ($b as $type_name => $details) {
     $bstart = $b[$type_name]['start'];
     break;
  }
  return strnatcmp($astart, $bstart);
}

/**
 * Used to sort the list of relationship parts by start position
 *
 * @ingroup tripal_feature
 */
function tripal_feature_sort_rel_parts_by_end($a, $b) {
  $val = strnatcmp($b['end'], $a['end']);
  if ($val == 0) {
     return strcmp($a['type'], $b['type']);
  }
  return $val;
}

/**
 * Returns the marked up fasta sequence for the described feature
 *
 * @param $sequence
 * @param $parts
 * @param $defline
 *
 * @ingroup tripal_feature
 */
function tripal_feature_color_sequence($sequence, $parts, $defline) {


  $types = array();
  // first get the list of types so we can create a color legend
  foreach ($parts as $index => $t) {
    foreach ($t as $type_name => $details) {
       $types[$type_name] = 1;
    }
  }

  $newseq = "<div id=\"tripal_feature-featureloc_sequence-legend\">Legend: ";
  foreach ($types as $type_name => $present) {
    $newseq .= "<span id=\"tripal_feature-legend-$type_name\" class=\"tripal_feature-legend-item tripal_feature-featureloc_sequence-$type_name\" script=\"\">$type_name</span>";
  }
  $newseq .= "</div>Hold the cursor over a type above to highlight its positions in the sequence below. The colors in the sequence below merge when types overlap.";


  // set the background color of the rows based on the type
  $pos = 0;
  $newseq .= "<pre id=\"tripal_feature-featureloc_sequence\">";
  $newseq .= ">$defline\n";

  // iterate through the parts. They should be in order.
  $ends = array();
  $seqcount = 0;
  foreach ($parts as $index => $types) {

    // get the start for this part.  All types in this part start at the
    // same position so we only need the first record
    foreach ($types as $type => $child) {
      $start = $child['start'];
      break;
    }

    // add in the sequence up to the start of this part
    for ($i = $pos; $i < $start; $i++) {
      $newseq .= $sequence{$pos};
      $seqcount++;
      if ($seqcount % 50 == 0) {
        $newseq .= "\n";
      }
      if (array_key_exists($pos, $ends)) {
        foreach ($ends[$pos] as $end) {
          $newseq .= "</span>";
        }
      }
      $pos++;
    }

    // we want to sort the parts by their end. We want the span tag to
    // to be added in the order the parts end.
    usort($types, 'tripal_feature_sort_rel_parts_by_end');

    // now add the child span for all types that start at this position
    foreach ($types as $type) {
      $class = "tripal_feature-featureloc_sequence-" . $type['type'];
      $newseq .= "<span class=\"$class\">";
      // add the end position
      $end = $type['end'];
      $ends[$end][] = $end;
    }
  }

  // add in rest of the sequence
  for ($i = $pos; $i < strlen($sequence); $i++) {
    $newseq .= $sequence{$pos};
    $seqcount++;
    if ($seqcount % 50 == 0) {
      $newseq .= "\n";
    }
    if (array_key_exists($pos, $ends)) {
      foreach ($ends[$pos] as $end) {
        $newseq .= "</span>";
      }
    }
    $pos++;
  }

  $newseq .= "</pre>";
  return $newseq;
}

/**
 * The CV module will create the JSON array necessary for buillding a
 * pie chart using jgChart and Google Charts.  We have to pass to it
 * a table that contains count information, tell it which column
 * contains the cvterm_id and provide a filter for getting the
 * results we want from the table.
 *
 * @ingroup tripal_feature
 */
function tripal_feature_cv_chart($chart_id) {

  // we only want the chart to show feature types setup by the admin
  $temp = rtrim(variable_get('tripal_feature_summary_report_mapping', ''));
  $where = '';
  if ($temp) {
    $temp = explode("\n", $temp);
    foreach ($temp as $key => $value) {
      $temp2 = explode("=", $value);
      $feature_type = rtrim($temp2[0]);
      $where .= "CNT.feature_type = '$feature_type' OR \n";
    }
    if ($where) {
      $where = drupal_substr($where, 0, -5);  # remove OR from the end
      $where = "($where) AND";
    }
  }

  $organism_id = preg_replace("/^tripal_feature_cv_chart_(\d+)$/", "$1", $chart_id);

  $options = array(
    count_mview      => 'organism_feature_count',
    cvterm_id_column => 'cvterm_id',
    count_column     => 'num_features',
    size             => '550x200',
    filter           => "$where CNT.organism_id = $organism_id",
  );
  return $options;
}

/**
 * The CV module will create the JSON array necessary for buillding a
 * pie chart using jgChart and Google Charts.  We have to pass to it
 * a table that contains count information, tell it which column
 * contains the cvterm_id and provide a filter for getting the
 * results we want from the table.
 *
 * @ingroup tripal_feature
 */
function tripal_feature_cv_tree($tree_id) {

  $organism_id = preg_replace("/^tripal_feature_cv_tree_(\d+)$/", "$1", $tree_id);
  $options = array(
    cv_id            => tripal_cv_get_cv_id('sequence'),
    count_mview      => 'organism_feature_count',
    cvterm_id_column => 'cvterm_id',
    count_column     => 'num_features',
    filter           => "CNT.organism_id = $organism_id",
    label            => 'Features',
  );
  return $options;
}

/**
 * Implements hook_job_describe_args() in order to describe the various feature jobs
 * to the tripal jobs interface.
 *
 * @ingroup tripal_feature
 */
function tripal_feature_job_describe_args($callback, $args) {

  $new_args = array();
  if ($callback == 'tripal_feature_load_fasta') {
    $new_args['FASTA file'] = $args[0];
    $organism = chado_select_record('organism', array('genus', 'species'), array('organism_id' => $args[1]));
    $new_args['Organism'] = $organism[0]->genus . " " . $organism[0]->species;
    $new_args['Sequence Type'] = $args[2];
    $new_args['Name Match Type'] = $args[14];
    $new_args['Name RE'] = $args[4];
    $new_args['Unique Name RE'] = $args[5];

    // add in the relationship arguments
    $new_args['Relationship Type'] = $args[8];
    $new_args['Relationship Parent RE'] = $args[9];
    $new_args['Relationship Parent Type'] = $args[10];

    // add in the database reference arguments
    if ($args[7]) {
      $db = chado_select_record('db', array('name'), array('db_id' => $args[7]));
    }
    $new_args['Database Reference'] = $db[0]->name;
    $new_args['Accession RE'] = $args[6];
    $new_args['Method'] = $args[11];

    // add in the analysis
    if ($args[13]) {
      $analysis = chado_select_record('analysis', array('name'), array('analysis_id' => $args[13]));
    }
    $new_args['Analysis'] = $analysis[0]->name;
  }
  if ($callback == 'tripal_feature_delete_features') {
    if ($args[0]) {
      $organism = chado_select_record('organism', array('genus', 'species'), array('organism_id' => $args[0]));
      $new_args['Organism'] = $organism[0]->genus . " " . $organism[0]->species;
    }
    else {
      $new_args['Organism'] = '';
    }

    if ($args[1]) {
      $analysis = chado_select_record('analysis', array('name'), array('analysis_id' => $args[1]));
      $new_args['Analysis'] = $analysis[0]->name;
    }
    else {
      $new_args['Analysis'] = '';
    }

    $new_args['Sequence Type'] = $args[2];
    $new_args['Is Unique Name'] = $args[3];
    $new_args['Features Names'] = $args[4];

  }
  elseif ($callback == 'tripal_feature_load_gff3') {

    $new_args['GFF File'] = $args[0];
    $organism = chado_select_record('organism', array('genus', 'species'), array('organism_id' => $args[1]));
    $new_args['Organism'] = $organism[0]->genus . " " . $organism[0]->species;
    $analysis = chado_select_record('analysis', array('name'), array('analysis_id' => $args[2]));
    $new_args['Analysis'] = $analysis[0]->name;
    $new_args['Use a Transaction'] = ($args[7] == 1) ? "Yes" : "No";
    $new_args['Import only new features'] = ($args[3] == 1) ? "Yes" : "No";
    $new_args['Import all and update'] = ($args[4] == 1) ? "Yes" : "No";
    $new_args['Import all and replace'] = ($args[5] == 1) ? "Yes" : "No";
    $new_args['Delete features'] = ($args[6] == 1) ? "Yes" : "No";
    if ($args[8]) {
      $target_organism = chado_select_record('organism', array('genus', 'species'), array('organism_id' => $args[8]));
      $new_args['Target organism'] = $target_organism[0]->genus . " " . $target_organism[0]->species;
    }
    else {
      $new_args['Target organism'] = '';
    }
    $new_args['Target type'] = $args[9];
    $new_args['Create target'] = ($args[10] == 1) ? "Yes" : "No";
    $new_args['Starting line'] = $args[11];
    $new_args['Landmark Type'] = $args[12];
    $new_args['Alternate ID attribute'] = $args[13];
    $new_args['Create Organism'] = ($args[14] == 1) ? "Yes" : "No";
  }
  return $new_args;
}

/**
 * Implements hook_coder_ignore().
 *
 * Defines the path to the file (tripal_core.coder_ignores.txt) where ignore rules for
 * coder are stored
 *
 * @ingroup tripal_feature
 */
function tripal_feature_coder_ignore() {
  return array(
    'path' => drupal_get_path('module', 'tripal_feature'),
    'line prefix' => drupal_get_path('module', 'tripal_feature'),
  );
}

/*
 * Uses the value provided in the $id argument to find all features that match
 * that ID by name, featurename or synonym.  If it matches uniquenly to a single
 * feature it will redirect to that feature page, otherwise, a list of matching
 * features is shown.
 *
 * @ingroup tripal_feature
 */
function tripal_feature_match_features_page($id) {

  // if the URL alias configuration is set such that the URL
  // always begins with 'feature' then we want to use the ID as it is and
  // forward it on. Otherwise, try to find the matching feature.
  $url_alias = variable_get('chado_feature_url_string', '/feature/[genus]/[species]/[type]/[uniquename]');
  if (!$url_alias) {
    $url_alias = '/feature/[genus]/[species]/[type]/[uniquename]';
  }
  $url_alias = preg_replace('/^\//', '', $url_alias); // remove any preceeding forward slash
  if (preg_match('/^feature\//', $url_alias)) {
    drupal_goto($id);
  }

  $sql = "
    SELECT
      F.name, F.uniquename, F.feature_id,
      O.genus, O.species, O.organism_id,
      CVT.cvterm_id, CVT.name as type_name,
      CF.nid,
      array_agg(S.name) as synonyms
    FROM {feature} F
      INNER JOIN {organism} O on F.organism_id = O.organism_id
      INNER JOIN {cvterm} CVT on CVT.cvterm_id = F.type_id
      LEFT JOIN {feature_synonym} FS on FS.feature_id = F.feature_id
      LEFT JOIN {synonym} S on S.synonym_id = FS.synonym_id
      INNER JOIN public.chado_feature CF on CF.feature_id = F.feature_id
    WHERE
      F.uniquename = :uname or
      F.name = :fname' or
      S.name = :sname
    GROUP BY F.name, F.uniquename, F.feature_id, O.genus, O.species,
      O.organism_id, CVT.cvterm_id, CVT.name, CF.nid
  ";
  $results = chado_query($sql, array(':uname' => $id, ':fname' => $id, ':sname' => $id));

  $num_matches = 0;

  // iterate through the matches and build the table for showing matches
  $header = array('Uniquename', 'Name', 'Type', 'Species', 'Synonyms');
  $rows = array();
  $curr_match;
  while ($match = $results->fetchObject()) {
    $curr_match = $match;
    $synonyms = $match->synonyms;
    $synonyms = preg_replace('/[\"\{\}]/', '', $synonyms);
    $rows[] = array(
       $match->uniquename,
       "<a href=\"" . url("node/" . $match->nid) . "\">" . $match->name . "</a>",
       $match->type_name,
       '<i>' . $match->genus . ' ' . $match->species . '</i>',
       $synonyms,
    );
    $num_matches++;
  }

  // if we have more than one match then generate the table, otherwise, redirect
  // to the matched feature
  if ($num_matches == 1) {
    drupal_goto("node/" . $curr_match->nid);
  }
  if ($num_matches == 0) {
    return "<p>No features matched the given name '$id'</p>";
  }

  $table_attrs = array(
    'class' => 'tripal-table tripal-table-horz'
  );
  $output = "<p>The following features match the name '$id'.</p>";
  $output .= theme_table($header, $rows, $table_attrs, $caption);
  return $output;
}

/**
 * Implementation of hook_form_alter()
 *
 * @param $form
 * @param $form_state
 * @param $form_id
 *
 * @ingroup tripal_feature
 */
function tripal_feature_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == "tripal_feature_seq_extract_form") {
    // updating the form through the ahah callback sets the action of
    // the form to the ahah callback URL. We need to set it back
    // to the normal form URL
    $form['#action'] = url("find/sequences");
  }
  // turn off preview button for insert/updates
  if ($form_id == "chado_feature_node_form") {
    $form['actions']['preview']['#access'] = FALSE;
  }
}
